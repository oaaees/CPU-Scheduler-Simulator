#include "algorithmsinfo.h"

AlgorithmsInfo::AlgorithmsInfo() {
    FCFS_info = "## Algoritmo FCFS (Primero en llegar, primero en ejecutar)\n\nEs uno de los algoritmos de planificación de procesos más sencillos. Como su nombre indica, los procesos se ejecutan en el orden exacto en que llegan a la cola de listos. Es como una cola en un supermercado: el primero en llegar es el primero en ser atendido.\n\n**Características principales:**\n\n-   **Simple:** Es fácil de entender e implementar.\n-   **Justo:** Todos los procesos reciben un trato igualitario, sin privilegios.\n-   **No preemptivo:** Un proceso en ejecución no puede ser interrumpido hasta que termine.\n\n**Cómo funciona:**\n\n1.  **Cola de listos:** Los procesos que están listos para ejecutarse se colocan en una cola.\n2.  **Selección del proceso:** El primer proceso de la cola es seleccionado para ejecutarse.\n3.  **Ejecución:** El proceso seleccionado se ejecuta hasta que finaliza o es bloqueado por alguna razón (por ejemplo, esperando una entrada/salida).\n4.  **Retorno a la cola:** Si el proceso es bloqueado, vuelve a la cola de listos al finalizar su bloqueo.\n\n**Ventajas:**\n\n-   **Sencillo:** Fácil de implementar y entender.\n-   **Justo:** Todos los procesos son tratados de igual manera.\n\n**Desventajas:**\n\n-   **Ineficiente:** Un proceso largo al inicio de la cola puede retrasar a todos los demás, incluso si hay procesos cortos esperando.\n-   **No considera la duración de los procesos:** No prioriza procesos cortos sobre largos, lo que puede llevar a tiempos de espera elevados para procesos cortos.\n";
    SJF_info = "## Algoritmo SJF (Shortest Job First)\n\nEl algoritmo SJF es una estrategia de planificación de procesos que busca minimizar el tiempo de respuesta promedio. La idea central es seleccionar para su ejecución, entre todos los procesos listos, aquel que tenga la ráfaga de CPU más corta (es decir, el que necesite menos tiempo de procesador para completar su ejecución).\n\n**Funcionamiento:**\n\n1.  **Cola de listos:** Al igual que en FCFS, los procesos se colocan en una cola de listos cuando están preparados para ejecutarse.\n2.  **Selección del proceso:** En cada instante de tiempo, el planificador selecciona el proceso de la cola de listos con el tiempo de ejecución estimado más corto.\n3.  **Ejecución:** El proceso seleccionado se ejecuta hasta que finaliza o es bloqueado por alguna razón (por ejemplo, esperando una entrada/salida).\n4.  **Retorno a la cola:** Si el proceso es bloqueado, vuelve a la cola de listos al finalizar su bloqueo.\n\n**Ventajas:**\n\n-   **Minimiza el tiempo de respuesta promedio:** Al ejecutar primero los procesos más cortos, se reduce el tiempo que los procesos esperan en la cola.\n-   **Optimo:** En términos teóricos, es el algoritmo óptimo para minimizar el tiempo de respuesta promedio.\n\n**Desventajas:**\n\n-   **Información a priori:** Requiere conocer de antemano el tiempo de ejecución de cada proceso, lo cual en la práctica es difícil de determinar con exactitud.\n-   **Hambruna de procesos largos:** Los procesos largos pueden esperar mucho tiempo para ser ejecutados si continuamente llegan procesos cortos.\n-   **No preemptivo:** En su versión básica, SJF no permite la preemption, lo que significa que un proceso en ejecución no puede ser interrumpido por otro, incluso si llega un proceso más corto.";
    random_selection_info = "## Algoritmo de Selección Aleatoria\n\nEl algoritmo de selección aleatoria, como su nombre indica, selecciona un proceso de la cola de listos de manera completamente aleatoria para su ejecución. A diferencia de algoritmos como FCFS o SJF, que siguen reglas específicas para la selección, este algoritmo se basa puramente en el azar.\n\n### Funcionamiento\n\n1.  **Cola de listos:** Los procesos se colocan en una cola de listos, como en los algoritmos anteriores.\n2.  **Selección del proceso:** En cada instante de tiempo, se selecciona un proceso al azar de la cola de listos para su ejecución. Esta selección es similar a sacar una bola de una tómbola.\n3.  **Ejecución:** El proceso seleccionado se ejecuta hasta que finaliza o es bloqueado.\n4.  **Retorno a la cola:** Si el proceso es bloqueado, vuelve a la cola de listos.\n\n### Ventajas\n\n-   **Sencillez:** Es muy fácil de implementar, ya que no requiere cálculos complejos o información adicional sobre los procesos.\n-   **Equidad:** En teoría, todos los procesos tienen las mismas oportunidades de ser ejecutados, lo que puede ser visto como una forma justa de asignar recursos.\n\n### Desventajas\n\n-   **Ineficiencia:** La selección aleatoria no garantiza una buena utilización del procesador ni un tiempo de respuesta óptimo. Puede ocurrir que procesos cortos se vean retrasados por procesos largos seleccionados al azar.\n-   **Impredecibilidad:** Los resultados pueden variar mucho de una ejecución a otra, lo que dificulta el análisis y la optimización del sistema.";
    np_priority_info = "## Algoritmo de Planificación Basada en Prioridades No Expulsivo\n\nEl algoritmo de planificación basado en prioridades asigna a cada proceso un nivel de prioridad. Los procesos con mayor prioridad son ejecutados antes que aquellos con menor prioridad. En su versión no expulsiva, un proceso en ejecución no puede ser interrumpido por otro, incluso si llega un proceso con mayor prioridad.\n\n### Funcionamiento\n\n1.  **Asignación de prioridades:** A cada proceso se le asigna una prioridad, que puede ser estática (establecida al inicio y no modificada) o dinámica (puede cambiar durante la ejecución).\n2.  **Cola de listos:** Los procesos se colocan en una cola de listos, ordenados por su prioridad. Los procesos con mayor prioridad se ubican al principio de la cola.\n3.  **Selección del proceso:** El planificador siempre selecciona para su ejecución el proceso con la mayor prioridad que se encuentre en la cola de listos.\n4.  **Ejecución:** El proceso seleccionado se ejecuta hasta que finaliza o se bloquea.\n5.  **Retorno a la cola:** Si el proceso se bloquea, vuelve a la cola de listos manteniendo su prioridad.\n\n### Ventajas\n\n-   **Flexibilidad:** Permite dar preferencia a ciertos procesos críticos o importantes.\n-   **Fácil de implementar:** La lógica de selección es relativamente sencilla.\n\n### Desventajas\n\n-   **Hambruna:** Los procesos con baja prioridad pueden esperar indefinidamente si continuamente llegan procesos con mayor prioridad.\n-   **No expulsivo:** Un proceso con baja prioridad puede bloquear el procesador, impidiendo que otros procesos con mayor prioridad sean ejecutados.";
    round_robin_info = "## Algoritmo de Turno Rotativo (Round Robin)\n\nEl algoritmo de turno rotativo, o Round Robin, es una estrategia de planificación que asigna un quantum de tiempo fijo a cada proceso. Los procesos se ejecutan en orden de llegada, recibiendo cada uno un quantum de tiempo para ejecutarse. Si un proceso no termina en su quantum asignado, se interrumpe y se coloca al final de la cola de listos para esperar su siguiente turno.\n\n### Funcionamiento\n\n1.  **Quantum de tiempo:** Se define un quantum de tiempo, que representa el máximo tiempo que un proceso puede ejecutarse de forma continua.\n2.  **Cola de listos:** Los procesos se colocan en una cola de listos, ordenados por su orden de llegada.\n3.  **Selección del proceso:** El planificador selecciona el primer proceso de la cola y le asigna un quantum de tiempo.\n4.  **Ejecución:** El proceso seleccionado se ejecuta durante un quantum de tiempo o hasta que finaliza, lo que ocurra primero.\n5.  **Retorno a la cola:** Si el proceso no ha finalizado al término del quantum, se interrumpe y se coloca al final de la cola. El planificador pasa al siguiente proceso de la cola.\n\n### Ventajas\n\n-   **Equidad:** Todos los procesos reciben un turno de ejecución de forma regular, evitando que un proceso monopolice el procesador.\n-   **Interactividad:** Es adecuado para sistemas interactivos, ya que los procesos de usuario reciben una respuesta relativamente rápida.\n\n### Desventajas\n\n-   **Sobrecarga:** Si el quantum es demasiado pequeño, se produce una alta sobrecarga de contexto, ya que el procesador debe cambiar de tarea con frecuencia.\n-   **Respuesta variable:** El tiempo de respuesta de un proceso puede variar significativamente dependiendo de su posición en la cola y del quantum de tiempo.";
    SRTF_info = "## Algoritmo SRTF (Shortest Remaining Time First) Expulsivo\n\nEl algoritmo SRTF (Shortest Remaining Time First) o Primero el Menor Tiempo Restante, en su versión expulsiva, es una variante del algoritmo SJF que permite interrumpir un proceso en ejecución si llega otro proceso con un tiempo de ejecución restante estimado menor. Esto lo diferencia del SJF básico, que no permitía la preempción.\n\n### Funcionamiento\n\n1.  **Estimación del tiempo restante:** A cada proceso se le asigna una estimación del tiempo restante para su ejecución. Esta estimación puede ser inicial y ajustarse a medida que el proceso avanza.\n2.  **Cola de listos:** Los procesos se colocan en una cola de listos, ordenados por su tiempo de ejecución restante estimado.\n3.  **Selección del proceso:** El planificador siempre selecciona para su ejecución el proceso con el menor tiempo de ejecución restante estimado en la cola de listos.\n4.  **Ejecución:** El proceso seleccionado se ejecuta hasta que finaliza, se bloquea o llega otro proceso con un tiempo de ejecución restante estimado menor. En este último caso, el proceso en ejecución se interrumpe y se coloca al final de la cola de listos, mientras que el nuevo proceso se ejecuta.\n5.  **Retorno a la cola:** Si un proceso es interrumpido o bloqueado, vuelve a la cola de listos manteniendo su tiempo de ejecución restante actualizado.\n\n### Ventajas\n\n-   **Minimiza el tiempo de respuesta promedio:** Al permitir la preempción, se reduce el tiempo de espera de los procesos cortos, mejorando el tiempo de respuesta promedio.\n-   **Adaptabilidad:** Se adapta bien a situaciones donde el tiempo de ejecución de los procesos puede variar.\n\n### Desventajas\n\n-   **Sobrecarga:** La alta frecuencia de interrupciones puede generar una sobrecarga significativa en el sistema.\n-   **Información a priori:** Requiere una estimación precisa del tiempo de ejecución restante, lo cual puede ser difícil de obtener en la práctica.\n-   **Hambruna:** Los procesos largos pueden sufrir hambruna si continuamente llegan procesos cortos.";
    p_priority_info = "## Algoritmo de Planificación Basada en Prioridades Expulsivo\n\nEl algoritmo de planificación basado en prioridades expulsivo es una variante del algoritmo de planificación basado en prioridades que permite interrumpir un proceso en ejecución si llega otro proceso con una prioridad más alta. Esto significa que un proceso con menor prioridad puede ser expulsado del procesador para dar paso a uno más importante.\n\n### Funcionamiento\n\n1.  **Asignación de prioridades:** A cada proceso se le asigna una prioridad numérica, donde un número menor indica una prioridad más alta.\n2.  **Cola de listos:** Los procesos se colocan en una cola de listos, ordenados por su prioridad. Los procesos con mayor prioridad se ubican al principio de la cola.\n3.  **Selección del proceso:** El planificador siempre selecciona para su ejecución el proceso con la mayor prioridad que se encuentre en la cola de listos.\n4.  **Ejecución:** El proceso seleccionado se ejecuta hasta que finaliza, se bloquea o llega otro proceso con una prioridad más alta. En este último caso, el proceso en ejecución se interrumpe y se coloca al final de la cola de listos, mientras que el nuevo proceso con mayor prioridad se ejecuta.\n5.  **Retorno a la cola:** Si un proceso es interrumpido o bloqueado, vuelve a la cola de listos manteniendo su prioridad.\n\n### Ventajas\n\n-   **Flexibilidad:** Permite dar preferencia a procesos críticos o importantes.\n-   **Adaptabilidad:** Puede adaptarse a cambios en la importancia relativa de los procesos.\n\n### Desventajas\n\n-   **Hambruna:** Los procesos con baja prioridad pueden sufrir hambruna si continuamente llegan procesos con mayor prioridad.\n-   **Sobrecarga:** La alta frecuencia de interrupciones puede generar una sobrecarga significativa en el sistema.";
}
